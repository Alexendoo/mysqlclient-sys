/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __DARWIN_NBBY: ::std::os::raw::c_uint = 8;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const PROTOCOL_VERSION: ::std::os::raw::c_uint = 10;
pub const MYSQL_SERVER_VERSION: &'static [u8; 7usize] = b"5.7.11\x00";
pub const MYSQL_BASE_VERSION: &'static [u8; 11usize] = b"mysqld-5.7\x00";
pub const MYSQL_SERVER_SUFFIX_DEF: &'static [u8; 1usize] = b"\x00";
pub const FRM_VER: ::std::os::raw::c_uint = 6;
pub const MYSQL_VERSION_ID: ::std::os::raw::c_uint = 50711;
pub const MYSQL_PORT: ::std::os::raw::c_uint = 3306;
pub const MYSQL_PORT_DEFAULT: ::std::os::raw::c_uint = 0;
pub const MYSQL_UNIX_ADDR: &'static [u8; 16usize] = b"/tmp/mysql.sock\x00";
pub const MYSQL_CONFIG_NAME: &'static [u8; 3usize] = b"my\x00";
pub const MYSQL_COMPILATION_COMMENT: &'static [u8; 9usize] = b"Homebrew\x00";
pub const LIBMYSQL_VERSION: &'static [u8; 7usize] = b"5.7.11\x00";
pub const LIBMYSQL_VERSION_ID: ::std::os::raw::c_uint = 50711;
pub const SYS_SCHEMA_VERSION: &'static [u8; 6usize] = b"1.5.0\x00";
pub const DATETIME_MAX_DECIMALS: ::std::os::raw::c_uint = 6;
pub const HOSTNAME_LENGTH: ::std::os::raw::c_uint = 60;
pub const SYSTEM_CHARSET_MBMAXLEN: ::std::os::raw::c_uint = 3;
pub const FILENAME_CHARSET_MBMAXLEN: ::std::os::raw::c_uint = 5;
pub const NAME_CHAR_LEN: ::std::os::raw::c_uint = 64;
pub const USERNAME_CHAR_LENGTH: ::std::os::raw::c_uint = 32;
pub const USERNAME_CHAR_LENGTH_STR: &'static [u8; 3usize] = b"32\x00";
pub const NAME_LEN: ::std::os::raw::c_uint = 192;
pub const USERNAME_LENGTH: ::std::os::raw::c_uint = 96;
pub const MYSQL_AUTODETECT_CHARSET_NAME: &'static [u8; 5usize] = b"auto\x00";
pub const SERVER_VERSION_LENGTH: ::std::os::raw::c_uint = 60;
pub const SQLSTATE_LENGTH: ::std::os::raw::c_uint = 5;
pub const TABLE_COMMENT_INLINE_MAXLEN: ::std::os::raw::c_uint = 180;
pub const TABLE_COMMENT_MAXLEN: ::std::os::raw::c_uint = 2048;
pub const COLUMN_COMMENT_MAXLEN: ::std::os::raw::c_uint = 1024;
pub const INDEX_COMMENT_MAXLEN: ::std::os::raw::c_uint = 1024;
pub const TABLE_PARTITION_COMMENT_MAXLEN: ::std::os::raw::c_uint = 1024;
pub const MAX_PACKET_LENGTH: ::std::os::raw::c_uint = 16777215;
pub const USER_HOST_BUFF_SIZE: ::std::os::raw::c_uint = 158;
pub const LOCAL_HOST: &'static [u8; 10usize] = b"localhost\x00";
pub const LOCAL_HOST_NAMEDPIPE: &'static [u8; 2usize] = b".\x00";
pub const FRM_GCOL_HEADER_SIZE: ::std::os::raw::c_uint = 4;
pub const GENERATED_COLUMN_EXPRESSION_MAXLEN: ::std::os::raw::c_uint = 65531;
pub const SCRAMBLE_LENGTH: ::std::os::raw::c_uint = 20;
pub const AUTH_PLUGIN_DATA_PART_1_LENGTH: ::std::os::raw::c_uint = 8;
pub const SCRAMBLED_PASSWORD_CHAR_LENGTH: ::std::os::raw::c_uint = 41;
pub const NOT_NULL_FLAG: ::std::os::raw::c_uint = 1;
pub const PRI_KEY_FLAG: ::std::os::raw::c_uint = 2;
pub const UNIQUE_KEY_FLAG: ::std::os::raw::c_uint = 4;
pub const MULTIPLE_KEY_FLAG: ::std::os::raw::c_uint = 8;
pub const BLOB_FLAG: ::std::os::raw::c_uint = 16;
pub const UNSIGNED_FLAG: ::std::os::raw::c_uint = 32;
pub const ZEROFILL_FLAG: ::std::os::raw::c_uint = 64;
pub const BINARY_FLAG: ::std::os::raw::c_uint = 128;
pub const ENUM_FLAG: ::std::os::raw::c_uint = 256;
pub const AUTO_INCREMENT_FLAG: ::std::os::raw::c_uint = 512;
pub const TIMESTAMP_FLAG: ::std::os::raw::c_uint = 1024;
pub const SET_FLAG: ::std::os::raw::c_uint = 2048;
pub const NO_DEFAULT_VALUE_FLAG: ::std::os::raw::c_uint = 4096;
pub const ON_UPDATE_NOW_FLAG: ::std::os::raw::c_uint = 8192;
pub const NUM_FLAG: ::std::os::raw::c_uint = 32768;
pub const PART_KEY_FLAG: ::std::os::raw::c_uint = 16384;
pub const GROUP_FLAG: ::std::os::raw::c_uint = 32768;
pub const UNIQUE_FLAG: ::std::os::raw::c_uint = 65536;
pub const BINCMP_FLAG: ::std::os::raw::c_uint = 131072;
pub const GET_FIXED_FIELDS_FLAG: ::std::os::raw::c_uint = 262144;
pub const FIELD_IN_PART_FUNC_FLAG: ::std::os::raw::c_uint = 524288;
pub const FIELD_IN_ADD_INDEX: ::std::os::raw::c_uint = 1048576;
pub const FIELD_IS_RENAMED: ::std::os::raw::c_uint = 2097152;
pub const FIELD_FLAGS_STORAGE_MEDIA: ::std::os::raw::c_uint = 22;
pub const FIELD_FLAGS_STORAGE_MEDIA_MASK: ::std::os::raw::c_uint = 12582912;
pub const FIELD_FLAGS_COLUMN_FORMAT: ::std::os::raw::c_uint = 24;
pub const FIELD_FLAGS_COLUMN_FORMAT_MASK: ::std::os::raw::c_uint = 50331648;
pub const FIELD_IS_DROPPED: ::std::os::raw::c_uint = 67108864;
pub const EXPLICIT_NULL_FLAG: ::std::os::raw::c_uint = 134217728;
pub const REFRESH_GRANT: ::std::os::raw::c_uint = 1;
pub const REFRESH_LOG: ::std::os::raw::c_uint = 2;
pub const REFRESH_TABLES: ::std::os::raw::c_uint = 4;
pub const REFRESH_HOSTS: ::std::os::raw::c_uint = 8;
pub const REFRESH_STATUS: ::std::os::raw::c_uint = 16;
pub const REFRESH_THREADS: ::std::os::raw::c_uint = 32;
pub const REFRESH_SLAVE: ::std::os::raw::c_uint = 64;
pub const REFRESH_MASTER: ::std::os::raw::c_uint = 128;
pub const REFRESH_ERROR_LOG: ::std::os::raw::c_uint = 256;
pub const REFRESH_ENGINE_LOG: ::std::os::raw::c_uint = 512;
pub const REFRESH_BINARY_LOG: ::std::os::raw::c_uint = 1024;
pub const REFRESH_RELAY_LOG: ::std::os::raw::c_uint = 2048;
pub const REFRESH_GENERAL_LOG: ::std::os::raw::c_uint = 4096;
pub const REFRESH_SLOW_LOG: ::std::os::raw::c_uint = 8192;
pub const REFRESH_READ_LOCK: ::std::os::raw::c_uint = 16384;
pub const REFRESH_FAST: ::std::os::raw::c_uint = 32768;
pub const REFRESH_QUERY_CACHE: ::std::os::raw::c_uint = 65536;
pub const REFRESH_QUERY_CACHE_FREE: ::std::os::raw::c_uint = 131072;
pub const REFRESH_DES_KEY_FILE: ::std::os::raw::c_uint = 262144;
pub const REFRESH_USER_RESOURCES: ::std::os::raw::c_uint = 524288;
pub const REFRESH_FOR_EXPORT: ::std::os::raw::c_uint = 1048576;
pub const REFRESH_OPTIMIZER_COSTS: ::std::os::raw::c_uint = 2097152;
pub const CLIENT_LONG_PASSWORD: ::std::os::raw::c_uint = 1;
pub const CLIENT_FOUND_ROWS: ::std::os::raw::c_uint = 2;
pub const CLIENT_LONG_FLAG: ::std::os::raw::c_uint = 4;
pub const CLIENT_CONNECT_WITH_DB: ::std::os::raw::c_uint = 8;
pub const CLIENT_NO_SCHEMA: ::std::os::raw::c_uint = 16;
pub const CLIENT_COMPRESS: ::std::os::raw::c_uint = 32;
pub const CLIENT_ODBC: ::std::os::raw::c_uint = 64;
pub const CLIENT_LOCAL_FILES: ::std::os::raw::c_uint = 128;
pub const CLIENT_IGNORE_SPACE: ::std::os::raw::c_uint = 256;
pub const CLIENT_PROTOCOL_41: ::std::os::raw::c_uint = 512;
pub const CLIENT_INTERACTIVE: ::std::os::raw::c_uint = 1024;
pub const CLIENT_SSL: ::std::os::raw::c_uint = 2048;
pub const CLIENT_IGNORE_SIGPIPE: ::std::os::raw::c_uint = 4096;
pub const CLIENT_TRANSACTIONS: ::std::os::raw::c_uint = 8192;
pub const CLIENT_RESERVED: ::std::os::raw::c_uint = 16384;
pub const CLIENT_RESERVED2: ::std::os::raw::c_uint = 32768;
pub const CLIENT_MULTI_STATEMENTS: ::std::os::raw::c_uint = 65536;
pub const CLIENT_MULTI_RESULTS: ::std::os::raw::c_uint = 131072;
pub const CLIENT_PS_MULTI_RESULTS: ::std::os::raw::c_uint = 262144;
pub const CLIENT_PLUGIN_AUTH: ::std::os::raw::c_uint = 524288;
pub const CLIENT_CONNECT_ATTRS: ::std::os::raw::c_uint = 1048576;
pub const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA: ::std::os::raw::c_uint =
    2097152;
pub const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS: ::std::os::raw::c_uint =
    4194304;
pub const CLIENT_SESSION_TRACK: ::std::os::raw::c_uint = 8388608;
pub const CLIENT_DEPRECATE_EOF: ::std::os::raw::c_uint = 16777216;
pub const CLIENT_SSL_VERIFY_SERVER_CERT: ::std::os::raw::c_uint = 1073741824;
pub const CLIENT_REMEMBER_OPTIONS: ::std::os::raw::c_uint = 2147483648;
pub const CAN_CLIENT_COMPRESS: ::std::os::raw::c_uint = 0;
pub const SERVER_STATUS_IN_TRANS: ::std::os::raw::c_uint = 1;
pub const SERVER_STATUS_AUTOCOMMIT: ::std::os::raw::c_uint = 2;
pub const SERVER_MORE_RESULTS_EXISTS: ::std::os::raw::c_uint = 8;
pub const SERVER_QUERY_NO_GOOD_INDEX_USED: ::std::os::raw::c_uint = 16;
pub const SERVER_QUERY_NO_INDEX_USED: ::std::os::raw::c_uint = 32;
pub const SERVER_STATUS_CURSOR_EXISTS: ::std::os::raw::c_uint = 64;
pub const SERVER_STATUS_LAST_ROW_SENT: ::std::os::raw::c_uint = 128;
pub const SERVER_STATUS_DB_DROPPED: ::std::os::raw::c_uint = 256;
pub const SERVER_STATUS_NO_BACKSLASH_ESCAPES: ::std::os::raw::c_uint = 512;
pub const SERVER_STATUS_METADATA_CHANGED: ::std::os::raw::c_uint = 1024;
pub const SERVER_QUERY_WAS_SLOW: ::std::os::raw::c_uint = 2048;
pub const SERVER_PS_OUT_PARAMS: ::std::os::raw::c_uint = 4096;
pub const SERVER_STATUS_IN_TRANS_READONLY: ::std::os::raw::c_uint = 8192;
pub const SERVER_SESSION_STATE_CHANGED: ::std::os::raw::c_uint = 16384;
pub const SERVER_STATUS_CLEAR_SET: ::std::os::raw::c_uint = 19960;
pub const MYSQL_ERRMSG_SIZE: ::std::os::raw::c_uint = 512;
pub const NET_READ_TIMEOUT: ::std::os::raw::c_uint = 30;
pub const NET_WRITE_TIMEOUT: ::std::os::raw::c_uint = 60;
pub const NET_WAIT_TIMEOUT: ::std::os::raw::c_uint = 28800;
pub const ONLY_KILL_QUERY: ::std::os::raw::c_uint = 1;
pub const MAX_TINYINT_WIDTH: ::std::os::raw::c_uint = 3;
pub const MAX_SMALLINT_WIDTH: ::std::os::raw::c_uint = 5;
pub const MAX_MEDIUMINT_WIDTH: ::std::os::raw::c_uint = 8;
pub const MAX_INT_WIDTH: ::std::os::raw::c_uint = 10;
pub const MAX_BIGINT_WIDTH: ::std::os::raw::c_uint = 20;
pub const MAX_CHAR_WIDTH: ::std::os::raw::c_uint = 255;
pub const MAX_BLOB_WIDTH: ::std::os::raw::c_uint = 16777216;
pub const CLIENT_MULTI_QUERIES: ::std::os::raw::c_uint = 65536;
pub const NET_HEADER_SIZE: ::std::os::raw::c_uint = 4;
pub const COMP_HEADER_SIZE: ::std::os::raw::c_uint = 3;
pub const MYSQL_STMT_HEADER: ::std::os::raw::c_uint = 4;
pub const MYSQL_LONG_DATA_HEADER: ::std::os::raw::c_uint = 6;
pub const NOT_FIXED_DEC: ::std::os::raw::c_uint = 31;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101003;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const MYSQL_CLIENT_reserved1: ::std::os::raw::c_uint = 0;
pub const MYSQL_CLIENT_reserved2: ::std::os::raw::c_uint = 1;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN: ::std::os::raw::c_uint = 2;
pub const MYSQL_CLIENT_TRACE_PLUGIN: ::std::os::raw::c_uint = 3;
pub const MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION:
          ::std::os::raw::c_uint =
    256;
pub const MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION: ::std::os::raw::c_uint
          =
    256;
pub const MYSQL_CLIENT_MAX_PLUGINS: ::std::os::raw::c_uint = 4;
pub const MYSQL_USERNAME_LENGTH: ::std::os::raw::c_uint = 96;
pub const CR_AUTH_PLUGIN_ERROR: ::std::os::raw::c_uint = 3;
pub const CR_AUTH_HANDSHAKE: ::std::os::raw::c_uint = 2;
pub const CR_AUTH_USER_CREDENTIALS: ::std::os::raw::c_uint = 1;
pub const CR_ERROR: ::std::os::raw::c_uint = 0;
pub const CR_OK: ::std::os::raw::c_int = -1;
pub const CR_OK_HANDSHAKE_COMPLETE: ::std::os::raw::c_int = -2;
pub const PROXY_FLAG: ::std::os::raw::c_uint = 0;
pub const CLIENT_NET_READ_TIMEOUT: ::std::os::raw::c_uint = 31536000;
pub const CLIENT_NET_WRITE_TIMEOUT: ::std::os::raw::c_uint = 31536000;
pub const ALLOC_MAX_BLOCK_TO_DROP: ::std::os::raw::c_uint = 4096;
pub const ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP: ::std::os::raw::c_uint = 10;
pub const PSI_INSTRUMENT_ME: ::std::os::raw::c_uint = 0;
pub const PSI_NOT_INSTRUMENTED: ::std::os::raw::c_uint = 0;
pub const PSI_FLAG_GLOBAL: ::std::os::raw::c_uint = 1;
pub const PSI_FLAG_MUTABLE: ::std::os::raw::c_uint = 2;
pub const PSI_FLAG_THREAD: ::std::os::raw::c_uint = 4;
pub const PSI_FLAG_STAGE_PROGRESS: ::std::os::raw::c_uint = 8;
pub const PSI_RWLOCK_FLAG_SX: ::std::os::raw::c_uint = 16;
pub const PSI_FLAG_TRANSFER: ::std::os::raw::c_uint = 32;
pub const FIND_TYPE_BASIC: ::std::os::raw::c_uint = 0;
pub const FIND_TYPE_NO_PREFIX: ::std::os::raw::c_uint = 1;
pub const FIND_TYPE_NO_OVERWRITE: ::std::os::raw::c_uint = 2;
pub const FIND_TYPE_ALLOW_NUMBER: ::std::os::raw::c_uint = 4;
pub const FIND_TYPE_COMMA_TERM: ::std::os::raw::c_uint = 8;
pub const LOCAL_INFILE_ERROR_LEN: ::std::os::raw::c_uint = 512;
pub const MYSQL_NO_DATA: ::std::os::raw::c_uint = 100;
pub const MYSQL_DATA_TRUNCATED: ::std::os::raw::c_uint = 101;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 8usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type __mbstate_t = _bindgen_ty_1;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
               8usize);
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize);
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize);
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_mutexattr_t>() ,
               8usize);
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize);
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
               8usize);
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize);
    assert_eq!(::std::mem::align_of::<_opaque_pthread_t>() , 8usize);
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize);
    assert_eq!(::std::mem::align_of::<fd_set>() , 4usize);
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type my_bool = ::std::os::raw::c_char;
pub type my_socket = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_field_types {
    MYSQL_TYPE_DECIMAL = 0,
    MYSQL_TYPE_TINY = 1,
    MYSQL_TYPE_SHORT = 2,
    MYSQL_TYPE_LONG = 3,
    MYSQL_TYPE_FLOAT = 4,
    MYSQL_TYPE_DOUBLE = 5,
    MYSQL_TYPE_NULL = 6,
    MYSQL_TYPE_TIMESTAMP = 7,
    MYSQL_TYPE_LONGLONG = 8,
    MYSQL_TYPE_INT24 = 9,
    MYSQL_TYPE_DATE = 10,
    MYSQL_TYPE_TIME = 11,
    MYSQL_TYPE_DATETIME = 12,
    MYSQL_TYPE_YEAR = 13,
    MYSQL_TYPE_NEWDATE = 14,
    MYSQL_TYPE_VARCHAR = 15,
    MYSQL_TYPE_BIT = 16,
    MYSQL_TYPE_TIMESTAMP2 = 17,
    MYSQL_TYPE_DATETIME2 = 18,
    MYSQL_TYPE_TIME2 = 19,
    MYSQL_TYPE_JSON = 245,
    MYSQL_TYPE_NEWDECIMAL = 246,
    MYSQL_TYPE_ENUM = 247,
    MYSQL_TYPE_SET = 248,
    MYSQL_TYPE_TINY_BLOB = 249,
    MYSQL_TYPE_MEDIUM_BLOB = 250,
    MYSQL_TYPE_LONG_BLOB = 251,
    MYSQL_TYPE_BLOB = 252,
    MYSQL_TYPE_VAR_STRING = 253,
    MYSQL_TYPE_STRING = 254,
    MYSQL_TYPE_GEOMETRY = 255,
}
#[repr(u32)]
/**
  @enum  enum_server_command
  @brief You should add new commands to the end of this list, otherwise old
         servers won't be able to handle them as 'unsupported'.
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_server_command {
    COM_SLEEP = 0,
    COM_QUIT = 1,
    COM_INIT_DB = 2,
    COM_QUERY = 3,
    COM_FIELD_LIST = 4,
    COM_CREATE_DB = 5,
    COM_DROP_DB = 6,
    COM_REFRESH = 7,
    COM_SHUTDOWN = 8,
    COM_STATISTICS = 9,
    COM_PROCESS_INFO = 10,
    COM_CONNECT = 11,
    COM_PROCESS_KILL = 12,
    COM_DEBUG = 13,
    COM_PING = 14,
    COM_TIME = 15,
    COM_DELAYED_INSERT = 16,
    COM_CHANGE_USER = 17,
    COM_BINLOG_DUMP = 18,
    COM_TABLE_DUMP = 19,
    COM_CONNECT_OUT = 20,
    COM_REGISTER_SLAVE = 21,
    COM_STMT_PREPARE = 22,
    COM_STMT_EXECUTE = 23,
    COM_STMT_SEND_LONG_DATA = 24,
    COM_STMT_CLOSE = 25,
    COM_STMT_RESET = 26,
    COM_SET_OPTION = 27,
    COM_STMT_FETCH = 28,
    COM_DAEMON = 29,
    COM_BINLOG_DUMP_GTID = 30,
    COM_RESET_CONNECTION = 31,
    COM_END = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_vio([u8; 0]);
pub type Vio = st_vio;
#[repr(C)]
pub struct st_net {
    pub vio: *mut Vio,
    pub buff: *mut ::std::os::raw::c_uchar,
    pub buff_end: *mut ::std::os::raw::c_uchar,
    pub write_pos: *mut ::std::os::raw::c_uchar,
    pub read_pos: *mut ::std::os::raw::c_uchar,
    pub fd: my_socket,
    pub remain_in_buf: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub buf_length: ::std::os::raw::c_ulong,
    pub where_b: ::std::os::raw::c_ulong,
    pub max_packet: ::std::os::raw::c_ulong,
    pub max_packet_size: ::std::os::raw::c_ulong,
    pub pkt_nr: ::std::os::raw::c_uint,
    pub compress_pkt_nr: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub retry_count: ::std::os::raw::c_uint,
    pub fcntl: ::std::os::raw::c_int,
    pub return_status: *mut ::std::os::raw::c_uint,
    pub reading_or_writing: ::std::os::raw::c_uchar,
    pub save_char: ::std::os::raw::c_char,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub compress: my_bool,
    pub unused3: my_bool,
    pub unused: *mut ::std::os::raw::c_uchar,
    pub last_errno: ::std::os::raw::c_uint,
    pub error: ::std::os::raw::c_uchar,
    pub unused4: my_bool,
    pub unused5: my_bool,
    /** Client library error message buffer. Actually belongs to struct MYSQL. */
    pub last_error: [::std::os::raw::c_char; 512usize],
    /** Client library sqlstate buffer. Set along with the error message. */
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    /**
    Extension pointer, for the caller private use.
    Any program linking with the networking library can use this pointer,
    which is handy when private connection specific data needs to be
    maintained.
    The mysqld server process uses this pointer internally,
    to maintain the server internal instrumentation for the connection.
  */
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_net() {
    assert_eq!(::std::mem::size_of::<st_net>() , 680usize);
    assert_eq!(::std::mem::align_of::<st_net>() , 8usize);
}
pub type NET = st_net;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_enum_shutdown_level {
    SHUTDOWN_DEFAULT = 0,
    SHUTDOWN_WAIT_CONNECTIONS = 1,
    SHUTDOWN_WAIT_TRANSACTIONS = 2,
    SHUTDOWN_WAIT_UPDATES = 8,
    SHUTDOWN_WAIT_ALL_BUFFERS = 16,
    SHUTDOWN_WAIT_CRITICAL_BUFFERS = 17,
    KILL_QUERY = 254,
    KILL_CONNECTION = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_cursor_type {
    CURSOR_TYPE_NO_CURSOR = 0,
    CURSOR_TYPE_READ_ONLY = 1,
    CURSOR_TYPE_FOR_UPDATE = 2,
    CURSOR_TYPE_SCROLLABLE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_set_option {
    MYSQL_OPTION_MULTI_STATEMENTS_ON = 0,
    MYSQL_OPTION_MULTI_STATEMENTS_OFF = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_session_state_type {
    SESSION_TRACK_SYSTEM_VARIABLES = 0,
    SESSION_TRACK_SCHEMA = 1,
    SESSION_TRACK_STATE_CHANGE = 2,
    SESSION_TRACK_GTIDS = 3,
    SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4,
    SESSION_TRACK_TRANSACTION_STATE = 5,
}
extern "C" {
    pub fn my_net_init(net: *mut NET, vio: *mut Vio) -> my_bool;
}
extern "C" {
    pub fn my_net_local_init(net: *mut NET);
}
extern "C" {
    pub fn net_end(net: *mut NET);
}
extern "C" {
    pub fn net_clear(net: *mut NET, check_buffer: my_bool);
}
extern "C" {
    pub fn net_claim_memory_ownership(net: *mut NET);
}
extern "C" {
    pub fn net_realloc(net: *mut NET, length: usize) -> my_bool;
}
extern "C" {
    pub fn net_flush(net: *mut NET) -> my_bool;
}
extern "C" {
    pub fn my_net_write(net: *mut NET, packet: *const ::std::os::raw::c_uchar,
                        len: usize) -> my_bool;
}
extern "C" {
    pub fn net_write_command(net: *mut NET, command: ::std::os::raw::c_uchar,
                             header: *const ::std::os::raw::c_uchar,
                             head_len: usize,
                             packet: *const ::std::os::raw::c_uchar,
                             len: usize) -> my_bool;
}
extern "C" {
    pub fn net_write_packet(net: *mut NET,
                            packet: *const ::std::os::raw::c_uchar,
                            length: usize) -> my_bool;
}
extern "C" {
    pub fn my_net_read(net: *mut NET) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rand_struct {
    pub seed1: ::std::os::raw::c_ulong,
    pub seed2: ::std::os::raw::c_ulong,
    pub max_value: ::std::os::raw::c_ulong,
    pub max_value_dbl: f64,
}
#[test]
fn bindgen_test_layout_rand_struct() {
    assert_eq!(::std::mem::size_of::<rand_struct>() , 32usize);
    assert_eq!(::std::mem::align_of::<rand_struct>() , 8usize);
}
impl Clone for rand_struct {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Item_result {
    STRING_RESULT = 0,
    REAL_RESULT = 1,
    INT_RESULT = 2,
    ROW_RESULT = 3,
    DECIMAL_RESULT = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_udf_args {
    pub arg_count: ::std::os::raw::c_uint,
    pub arg_type: *mut Item_result,
    pub args: *mut *mut ::std::os::raw::c_char,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub maybe_null: *mut ::std::os::raw::c_char,
    pub attributes: *mut *mut ::std::os::raw::c_char,
    pub attribute_lengths: *mut ::std::os::raw::c_ulong,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_udf_args() {
    assert_eq!(::std::mem::size_of::<st_udf_args>() , 64usize);
    assert_eq!(::std::mem::align_of::<st_udf_args>() , 8usize);
}
impl Clone for st_udf_args {
    fn clone(&self) -> Self { *self }
}
pub type UDF_ARGS = st_udf_args;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_udf_init {
    pub maybe_null: my_bool,
    pub decimals: ::std::os::raw::c_uint,
    pub max_length: ::std::os::raw::c_ulong,
    pub ptr: *mut ::std::os::raw::c_char,
    pub const_item: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_udf_init() {
    assert_eq!(::std::mem::size_of::<st_udf_init>() , 40usize);
    assert_eq!(::std::mem::align_of::<st_udf_init>() , 8usize);
}
impl Clone for st_udf_init {
    fn clone(&self) -> Self { *self }
}
pub type UDF_INIT = st_udf_init;
extern "C" {
    pub fn randominit(arg1: *mut rand_struct, seed1: ::std::os::raw::c_ulong,
                      seed2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn my_rnd(arg1: *mut rand_struct) -> f64;
}
extern "C" {
    pub fn create_random_string(to: *mut ::std::os::raw::c_char,
                                length: ::std::os::raw::c_uint,
                                rand_st: *mut rand_struct);
}
extern "C" {
    pub fn hash_password(to: *mut ::std::os::raw::c_ulong,
                         password: *const ::std::os::raw::c_char,
                         password_len: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn make_scrambled_password_323(to: *mut ::std::os::raw::c_char,
                                       password:
                                           *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scramble_323(to: *mut ::std::os::raw::c_char,
                        message: *const ::std::os::raw::c_char,
                        password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn check_scramble_323(reply: *const ::std::os::raw::c_uchar,
                              message: *const ::std::os::raw::c_char,
                              salt: *mut ::std::os::raw::c_ulong) -> my_bool;
}
extern "C" {
    pub fn get_salt_from_password_323(res: *mut ::std::os::raw::c_ulong,
                                      password:
                                          *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_password_from_salt_323(to: *mut ::std::os::raw::c_char,
                                       salt: *const ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn make_scrambled_password(to: *mut ::std::os::raw::c_char,
                                   password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scramble(to: *mut ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                    password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn check_scramble(reply: *const ::std::os::raw::c_uchar,
                          message: *const ::std::os::raw::c_char,
                          hash_stage2: *const ::std::os::raw::c_uchar)
     -> my_bool;
}
extern "C" {
    pub fn get_salt_from_password(res: *mut ::std::os::raw::c_uchar,
                                  password: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_password_from_salt(to: *mut ::std::os::raw::c_char,
                                   hash_stage2:
                                       *const ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn octet2hex(to: *mut ::std::os::raw::c_char,
                     str: *const ::std::os::raw::c_char,
                     len: ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_tty_password(opt_message: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_errno_to_sqlstate(mysql_errno: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn my_thread_init() -> my_bool;
}
extern "C" {
    pub fn my_thread_end();
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_timestamp_type {
    MYSQL_TIMESTAMP_NONE = -2,
    MYSQL_TIMESTAMP_ERROR = -1,
    MYSQL_TIMESTAMP_DATE = 0,
    MYSQL_TIMESTAMP_DATETIME = 1,
    MYSQL_TIMESTAMP_TIME = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_time {
    pub year: ::std::os::raw::c_uint,
    pub month: ::std::os::raw::c_uint,
    pub day: ::std::os::raw::c_uint,
    pub hour: ::std::os::raw::c_uint,
    pub minute: ::std::os::raw::c_uint,
    pub second: ::std::os::raw::c_uint,
    /**< microseconds */
    pub second_part: ::std::os::raw::c_ulong,
    pub neg: my_bool,
    pub time_type: enum_mysql_timestamp_type,
}
#[test]
fn bindgen_test_layout_st_mysql_time() {
    assert_eq!(::std::mem::size_of::<st_mysql_time>() , 40usize);
    assert_eq!(::std::mem::align_of::<st_mysql_time>() , 8usize);
}
impl Clone for st_mysql_time {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_TIME = st_mysql_time;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_list {
    pub prev: *mut st_list,
    pub next: *mut st_list,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_list() {
    assert_eq!(::std::mem::size_of::<st_list>() , 24usize);
    assert_eq!(::std::mem::align_of::<st_list>() , 8usize);
}
impl Clone for st_list {
    fn clone(&self) -> Self { *self }
}
pub type LIST = st_list;
pub type list_walk_action =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn list_add(root: *mut LIST, element: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_delete(root: *mut LIST, element: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_cons(data: *mut ::std::os::raw::c_void, root: *mut LIST)
     -> *mut LIST;
}
extern "C" {
    pub fn list_reverse(root: *mut LIST) -> *mut LIST;
}
extern "C" {
    pub fn list_free(root: *mut LIST, free_data: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn list_length(arg1: *mut LIST) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn list_walk(arg1: *mut LIST, action: list_walk_action,
                     argument: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const P_ALL: _bindgen_ty_2 = _bindgen_ty_2::P_ALL;
pub const P_PID: _bindgen_ty_2 = _bindgen_ty_2::P_PID;
pub const P_PGID: _bindgen_ty_2 = _bindgen_ty_2::P_PGID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub use self::_bindgen_ty_2 as idtype_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>() , 64usize);
    assert_eq!(::std::mem::align_of::<__darwin_i386_thread_state>() , 4usize);
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>() , 2usize);
    assert_eq!(::std::mem::align_of::<__darwin_fp_control>() , 2usize);
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u16)
        }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u16)
        }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u16)
        }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u16)
        }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u16)
        }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn at_offset_6(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (192usize as u16)) >>
                                       6u32) as u16)
        }
    }
    #[inline]
    pub fn set_at_offset_6(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(192usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (192usize as u16);
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (768usize as u16)) >>
                                       8u32) as u16)
        }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(768usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (768usize as u16);
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3072usize as u16)) >>
                                       10u32) as u16)
        }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(3072usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (3072usize as u16);
    }
    #[inline]
    pub fn at_offset_12(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u16)) >>
                                       12u32) as u16)
        }
    }
    #[inline]
    pub fn set_at_offset_12(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(4096usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 12u32) & (4096usize as u16);
    }
    #[inline]
    pub fn at_offset_13(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (57344usize as u16)) >>
                                       13u32) as u16)
        }
    }
    #[inline]
    pub fn set_at_offset_13(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(57344usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 13u32) & (57344usize as u16);
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: u16,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>() , 2usize);
    assert_eq!(::std::mem::align_of::<__darwin_fp_status>() , 2usize);
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u16)) >>
                                       0u32) as u16)
        }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(1usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 0u32) & (1usize as u16);
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u16)) >>
                                       1u32) as u16)
        }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(2usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 1u32) & (2usize as u16);
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u16)) >>
                                       2u32) as u16)
        }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(4usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 2u32) & (4usize as u16);
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u16)) >>
                                       3u32) as u16)
        }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(8usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 3u32) & (8usize as u16);
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u16)) >>
                                       4u32) as u16)
        }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(16usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 4u32) & (16usize as u16);
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32usize as u16)) >>
                                       5u32) as u16)
        }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(32usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 5u32) & (32usize as u16);
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (64usize as u16)) >>
                                       6u32) as u16)
        }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(64usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 6u32) & (64usize as u16);
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u16)) >>
                                       7u32) as u16)
        }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(128usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 7u32) & (128usize as u16);
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (256usize as u16)) >>
                                       8u32) as u16)
        }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(256usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 8u32) & (256usize as u16);
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (512usize as u16)) >>
                                       9u32) as u16)
        }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(512usize as u16);
        self._bitfield_1 |= ((val as u16 as u16) << 9u32) & (512usize as u16);
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1024usize as u16)) >>
                                       10u32) as u16)
        }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(1024usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 10u32) & (1024usize as u16);
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14336usize as u16)) >>
                                       11u32) as u16)
        }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(14336usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 11u32) & (14336usize as u16);
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u16)) >>
                                       14u32) as u16)
        }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(16384usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 14u32) & (16384usize as u16);
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u16)) >>
                                       15u32) as u16)
        }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        self._bitfield_1 &= !(32768usize as u16);
        self._bitfield_1 |=
            ((val as u16 as u16) << 15u32) & (32768usize as u16);
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>() , 16usize);
    assert_eq!(::std::mem::align_of::<__darwin_mmst_reg>() , 1usize);
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>() , 16usize);
    assert_eq!(::std::mem::align_of::<__darwin_xmm_reg>() , 1usize);
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>() , 524usize);
    assert_eq!(::std::mem::align_of::<__darwin_i386_float_state>() , 4usize);
}
#[repr(C)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>() , 716usize);
    assert_eq!(::std::mem::align_of::<__darwin_i386_avx_state>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<__darwin_i386_exception_state>() ,
               4usize);
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>() , 32usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_debug_state32>() , 4usize);
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>() ,
               168usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_thread_state64>() ,
               8usize);
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>() ,
               524usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_float_state64>() , 4usize);
}
#[repr(C)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>() , 844usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_avx_state64>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_exception_state64>() ,
               8usize);
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>() , 64usize);
    assert_eq!(::std::mem::align_of::<__darwin_x86_debug_state64>() , 8usize);
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext32>() , 600usize);
    assert_eq!(::std::mem::align_of::<__darwin_mcontext32>() , 4usize);
}
#[repr(C)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx32>() , 792usize);
    assert_eq!(::std::mem::align_of::<__darwin_mcontext_avx32>() , 4usize);
}
#[repr(C)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext64>() , 712usize);
    assert_eq!(::std::mem::align_of::<__darwin_mcontext64>() , 8usize);
}
#[repr(C)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx64>() , 1032usize);
    assert_eq!(::std::mem::align_of::<__darwin_mcontext_avx64>() , 8usize);
}
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(::std::mem::size_of::<__darwin_sigaltstack>() , 24usize);
    assert_eq!(::std::mem::align_of::<__darwin_sigaltstack>() , 8usize);
}
impl Clone for __darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(::std::mem::size_of::<__darwin_ucontext>() , 56usize);
    assert_eq!(::std::mem::align_of::<__darwin_ucontext>() , 8usize);
}
impl Clone for __darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize);
    assert_eq!(::std::mem::align_of::<sigval>() , 8usize);
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 32usize);
    assert_eq!(::std::mem::align_of::<sigevent>() , 8usize);
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::std::mem::size_of::<__siginfo>() , 104usize);
    assert_eq!(::std::mem::align_of::<__siginfo>() , 8usize);
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction_u {
    pub __sa_handler: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>>,
    pub __sa_sigaction: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           ::std::os::raw::c_int,
                                                                                       arg2:
                                                                                           *mut __siginfo,
                                                                                       arg3:
                                                                                           *mut ::std::os::raw::c_void)>>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(::std::mem::size_of::<__sigaction_u>() , 8usize);
    assert_eq!(::std::mem::align_of::<__sigaction_u>() , 8usize);
}
impl Clone for __sigaction_u {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(::std::mem::size_of::<__sigaction>() , 24usize);
    assert_eq!(::std::mem::align_of::<__sigaction>() , 8usize);
}
impl Clone for __sigaction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 16usize);
    assert_eq!(::std::mem::align_of::<sigaction>() , 8usize);
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
pub type sig_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::std::mem::size_of::<sigvec>() , 16usize);
    assert_eq!(::std::mem::align_of::<sigvec>() , 8usize);
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize);
    assert_eq!(::std::mem::align_of::<sigstack>() , 8usize);
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>)
     -> ::std::option::Option<unsafe extern "C" fn()>;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize);
    assert_eq!(::std::mem::align_of::<rusage>() , 8usize);
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(::std::mem::size_of::<rusage_info_v0>() , 96usize);
    assert_eq!(::std::mem::align_of::<rusage_info_v0>() , 8usize);
}
impl Clone for rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(::std::mem::size_of::<rusage_info_v1>() , 144usize);
    assert_eq!(::std::mem::align_of::<rusage_info_v1>() , 8usize);
}
impl Clone for rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(::std::mem::size_of::<rusage_info_v2>() , 160usize);
    assert_eq!(::std::mem::align_of::<rusage_info_v2>() , 8usize);
}
impl Clone for rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(::std::mem::size_of::<rusage_info_v3>() , 232usize);
    assert_eq!(::std::mem::align_of::<rusage_info_v3>() , 8usize);
}
impl Clone for rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_current = rusage_info_v3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize);
    assert_eq!(::std::mem::align_of::<rlimit>() , 8usize);
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(::std::mem::size_of::<proc_rlimit_control_wakeupmon>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<proc_rlimit_control_wakeupmon>() ,
               4usize);
}
impl Clone for proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub w_T: __BindgenUnionField<wait__bindgen_ty_1>,
    pub w_S: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize);
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (127usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(127usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (127usize as u32);
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65280usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294901760usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize);
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65280usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294901760usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait>() , 4usize);
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 4usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub type div_t = _bindgen_ty_3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 8usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
pub type ldiv_t = _bindgen_ty_4;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_5>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_5>() , 8usize);
}
impl Clone for _bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
pub type lldiv_t = _bindgen_ty_5;
extern "C" {
    #[link_name = "__mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(arg1: *const ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(arg1: *mut *mut ::std::os::raw::c_void, arg2: usize,
                          arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut ::std::os::raw::c_void, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtol(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *const ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u_int32_t;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(arg1: u_int32_t) -> u_int32_t;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(arg1: *const ::std::os::raw::c_void,
                     arg2: *const ::std::os::raw::c_void, arg3: usize,
                     arg4: usize, arg5: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "daemon$1050"]
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                    arg3: usize,
                    arg4:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                      arg3: usize, arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                     arg3: usize,
                     arg4:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                       arg3: usize, arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn psort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn psort_r(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_b(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn qsort_r(arg1: *mut ::std::os::raw::c_void, arg2: usize,
                   arg3: usize, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn radixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                     arg2: ::std::os::raw::c_int,
                     arg3: *const ::std::os::raw::c_uchar,
                     arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                      arg2: ::std::os::raw::c_int,
                      arg3: *const ::std::os::raw::c_uchar,
                      arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_client_plugin {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut ::std::os::raw::c_char,
                                                         arg2: usize,
                                                         arg3:
                                                             ::std::os::raw::c_int,
                                                         arg4:
                                                             *mut __va_list_tag)
                                        -> ::std::os::raw::c_int>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn()
                                          -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<unsafe extern "C" fn(option:
                                                                *const ::std::os::raw::c_char,
                                                            arg1:
                                                                *const ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_st_mysql_client_plugin() {
    assert_eq!(::std::mem::size_of::<st_mysql_client_plugin>() , 88usize);
    assert_eq!(::std::mem::align_of::<st_mysql_client_plugin>() , 8usize);
}
impl Clone for st_mysql_client_plugin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct st_mysql {
    pub net: NET,
    pub connector_fd: *mut ::std::os::raw::c_uchar,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub passwd: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub server_version: *mut ::std::os::raw::c_char,
    pub host_info: *mut ::std::os::raw::c_char,
    pub info: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub charset: *mut st_mysql_charset_info_st,
    pub fields: *mut MYSQL_FIELD,
    pub field_alloc: MEM_ROOT,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub extra_info: my_ulonglong,
    pub thread_id: ::std::os::raw::c_ulong,
    pub packet_length: ::std::os::raw::c_ulong,
    pub port: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub server_capabilities: ::std::os::raw::c_ulong,
    pub protocol_version: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub server_status: ::std::os::raw::c_uint,
    pub server_language: ::std::os::raw::c_uint,
    pub warning_count: ::std::os::raw::c_uint,
    pub options: st_mysql_options,
    pub status: mysql_status,
    pub free_me: my_bool,
    pub reconnect: my_bool,
    pub scramble: [::std::os::raw::c_char; 21usize],
    pub unused1: my_bool,
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub unused5: *mut ::std::os::raw::c_void,
    pub stmts: *mut LIST,
    pub methods: *const st_mysql_methods,
    pub thd: *mut ::std::os::raw::c_void,
    pub unbuffered_fetch_owner: *mut my_bool,
    pub info_buffer: *mut ::std::os::raw::c_char,
    pub extension: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_charset_info_st([u8; 0]);
#[test]
fn bindgen_test_layout_st_mysql() {
    assert_eq!(::std::mem::size_of::<st_mysql>() , 1304usize);
    assert_eq!(::std::mem::align_of::<st_mysql>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio_info {
    pub protocol: st_plugin_vio_info__bindgen_ty_1,
    /**< it's set, if the protocol is SOCKET or TCP */
    pub socket: ::std::os::raw::c_int,
}
pub const st_plugin_vio_info_MYSQL_VIO_INVALID:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_INVALID;
pub const st_plugin_vio_info_MYSQL_VIO_TCP: st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_TCP;
pub const st_plugin_vio_info_MYSQL_VIO_SOCKET:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_SOCKET;
pub const st_plugin_vio_info_MYSQL_VIO_PIPE: st_plugin_vio_info__bindgen_ty_1
          =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_PIPE;
pub const st_plugin_vio_info_MYSQL_VIO_MEMORY:
          st_plugin_vio_info__bindgen_ty_1 =
    st_plugin_vio_info__bindgen_ty_1::MYSQL_VIO_MEMORY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum st_plugin_vio_info__bindgen_ty_1 {
    MYSQL_VIO_INVALID = 0,
    MYSQL_VIO_TCP = 1,
    MYSQL_VIO_SOCKET = 2,
    MYSQL_VIO_PIPE = 3,
    MYSQL_VIO_MEMORY = 4,
}
#[test]
fn bindgen_test_layout_st_plugin_vio_info() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio_info>() , 8usize);
    assert_eq!(::std::mem::align_of::<st_plugin_vio_info>() , 4usize);
}
impl Clone for st_plugin_vio_info {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_PLUGIN_VIO_INFO = st_plugin_vio_info;
/**
  Provides plugin access to communication channel
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_plugin_vio {
    /**
    Plugin provides a pointer reference and this function sets it to the
    contents of any incoming packet. Returns the packet length, or -1 if
    the plugin should terminate.
  */
    pub read_packet: ::std::option::Option<unsafe extern "C" fn(vio:
                                                                    *mut st_plugin_vio,
                                                                buf:
                                                                    *mut *mut ::std::os::raw::c_uchar)
                                               -> ::std::os::raw::c_int>,
    /**
    Plugin provides a buffer with data and the length and this
    function sends it as a packet. Returns 0 on success, 1 on failure.
  */
    pub write_packet: ::std::option::Option<unsafe extern "C" fn(vio:
                                                                     *mut st_plugin_vio,
                                                                 packet:
                                                                     *const ::std::os::raw::c_uchar,
                                                                 packet_len:
                                                                     ::std::os::raw::c_int)
                                                -> ::std::os::raw::c_int>,
    /**
    Fills in a st_plugin_vio_info structure, providing the information
    about the connection.
  */
    pub info: ::std::option::Option<unsafe extern "C" fn(vio:
                                                             *mut st_plugin_vio,
                                                         info:
                                                             *mut st_plugin_vio_info)>,
}
#[test]
fn bindgen_test_layout_st_plugin_vio() {
    assert_eq!(::std::mem::size_of::<st_plugin_vio>() , 24usize);
    assert_eq!(::std::mem::align_of::<st_plugin_vio>() , 8usize);
}
impl Clone for st_plugin_vio {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_PLUGIN_VIO = st_plugin_vio;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_client_plugin_AUTHENTICATION {
    pub type_: ::std::os::raw::c_int,
    pub interface_version: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub author: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub version: [::std::os::raw::c_uint; 3usize],
    pub license: *const ::std::os::raw::c_char,
    pub mysql_api: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             *mut ::std::os::raw::c_char,
                                                         arg2: usize,
                                                         arg3:
                                                             ::std::os::raw::c_int,
                                                         arg4:
                                                             *mut __va_list_tag)
                                        -> ::std::os::raw::c_int>,
    pub deinit: ::std::option::Option<unsafe extern "C" fn()
                                          -> ::std::os::raw::c_int>,
    pub options: ::std::option::Option<unsafe extern "C" fn(option:
                                                                *const ::std::os::raw::c_char,
                                                            arg1:
                                                                *const ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
    pub authenticate_user: ::std::option::Option<unsafe extern "C" fn(vio:
                                                                          *mut MYSQL_PLUGIN_VIO,
                                                                      mysql:
                                                                          *mut st_mysql)
                                                     ->
                                                         ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_st_mysql_client_plugin_AUTHENTICATION() {
    assert_eq!(::std::mem::size_of::<st_mysql_client_plugin_AUTHENTICATION>()
               , 96usize);
    assert_eq!(::std::mem::align_of::<st_mysql_client_plugin_AUTHENTICATION>()
               , 8usize);
}
impl Clone for st_mysql_client_plugin_AUTHENTICATION {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
  loads a plugin and initializes it

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param ...    arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin(mysql: *mut st_mysql,
                             name: *const ::std::os::raw::c_char,
                             type_: ::std::os::raw::c_int,
                             argc: ::std::os::raw::c_int, ...)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  loads a plugin and initializes it, taking va_list as an argument

  This is the same as mysql_load_plugin, but take va_list instead of
  a list of arguments.

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded, -1 to disable type check
  @param argc   number of arguments to pass to the plugin initialization
                function
  @param args   arguments for the plugin initialization function

  @retval
  a pointer to the loaded plugin, or NULL in case of a failure
*/
    pub fn mysql_load_plugin_v(mysql: *mut st_mysql,
                               name: *const ::std::os::raw::c_char,
                               type_: ::std::os::raw::c_int,
                               argc: ::std::os::raw::c_int,
                               args: *mut __va_list_tag)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  finds an already loaded plugin by name, or loads it, if necessary

  @param mysql  MYSQL structure.
  @param name   a name of the plugin to load
  @param type   type of plugin that should be loaded

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_find_plugin(mysql: *mut st_mysql,
                                    name: *const ::std::os::raw::c_char,
                                    type_: ::std::os::raw::c_int)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  adds a plugin structure to the list of loaded plugins

  This is useful if an application has the necessary functionality
  (for example, a special load data handler) statically linked into
  the application binary. It can use this function to register the plugin
  directly, avoiding the need to factor it out into a shared object.

  @param mysql  MYSQL structure. It is only used for error reporting
  @param plugin an st_mysql_client_plugin structure to register

  @retval
  a pointer to the plugin, or NULL in case of a failure
*/
    pub fn mysql_client_register_plugin(mysql: *mut st_mysql,
                                        plugin: *mut st_mysql_client_plugin)
     -> *mut st_mysql_client_plugin;
}
extern "C" {
    /**
  set plugin options

  Can be used to set extra options and affect behavior for a plugin.
  This function may be called multiple times to set several options

  @param plugin an st_mysql_client_plugin structure
  @param option a string which specifies the option to set
  @param value  value for the option.

  @retval 0 on success, 1 in case of failure
**/
    pub fn mysql_plugin_options(plugin: *mut st_mysql_client_plugin,
                                option: *const ::std::os::raw::c_char,
                                value: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "mysql_port"]
    pub static mut mysql_port: ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "mysql_unix_port"]
    pub static mut mysql_unix_port: *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_field {
    pub name: *mut ::std::os::raw::c_char,
    pub org_name: *mut ::std::os::raw::c_char,
    pub table: *mut ::std::os::raw::c_char,
    pub org_table: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub catalog: *mut ::std::os::raw::c_char,
    pub def: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_ulong,
    pub max_length: ::std::os::raw::c_ulong,
    pub name_length: ::std::os::raw::c_uint,
    pub org_name_length: ::std::os::raw::c_uint,
    pub table_length: ::std::os::raw::c_uint,
    pub org_table_length: ::std::os::raw::c_uint,
    pub db_length: ::std::os::raw::c_uint,
    pub catalog_length: ::std::os::raw::c_uint,
    pub def_length: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub decimals: ::std::os::raw::c_uint,
    pub charsetnr: ::std::os::raw::c_uint,
    pub type_: enum_field_types,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_field() {
    assert_eq!(::std::mem::size_of::<st_mysql_field>() , 128usize);
    assert_eq!(::std::mem::align_of::<st_mysql_field>() , 8usize);
}
impl Clone for st_mysql_field {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_FIELD = st_mysql_field;
pub type MYSQL_ROW = *mut *mut ::std::os::raw::c_char;
pub type MYSQL_FIELD_OFFSET = ::std::os::raw::c_uint;
pub type my_ulonglong = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PSI_thread([u8; 0]);
/**
  Instrumented memory key.
  To instrument memory, a memory key must be obtained using @c register_memory.
  Using a zero key always disable the instrumentation.
*/
pub type PSI_memory_key = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_used_mem {
    pub next: *mut st_used_mem,
    pub left: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_st_used_mem() {
    assert_eq!(::std::mem::size_of::<st_used_mem>() , 16usize);
    assert_eq!(::std::mem::align_of::<st_used_mem>() , 8usize);
}
impl Clone for st_used_mem {
    fn clone(&self) -> Self { *self }
}
pub type USED_MEM = st_used_mem;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mem_root {
    pub free: *mut USED_MEM,
    pub used: *mut USED_MEM,
    pub pre_alloc: *mut USED_MEM,
    pub min_malloc: usize,
    pub block_size: usize,
    pub block_num: ::std::os::raw::c_uint,
    pub first_block_usage: ::std::os::raw::c_uint,
    pub max_capacity: usize,
    pub allocated_size: usize,
    pub error_for_capacity_exceeded: my_bool,
    pub error_handler: ::std::option::Option<unsafe extern "C" fn()>,
    pub m_psi_key: PSI_memory_key,
}
#[test]
fn bindgen_test_layout_st_mem_root() {
    assert_eq!(::std::mem::size_of::<st_mem_root>() , 88usize);
    assert_eq!(::std::mem::align_of::<st_mem_root>() , 8usize);
}
impl Clone for st_mem_root {
    fn clone(&self) -> Self { *self }
}
pub type MEM_ROOT = st_mem_root;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_typelib {
    pub count: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub type_names: *mut *const ::std::os::raw::c_char,
    pub type_lengths: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_st_typelib() {
    assert_eq!(::std::mem::size_of::<st_typelib>() , 32usize);
    assert_eq!(::std::mem::align_of::<st_typelib>() , 8usize);
}
impl Clone for st_typelib {
    fn clone(&self) -> Self { *self }
}
pub type TYPELIB = st_typelib;
extern "C" {
    pub fn find_typeset(x: *mut ::std::os::raw::c_char, typelib: *mut TYPELIB,
                        error_position: *mut ::std::os::raw::c_int)
     -> my_ulonglong;
}
extern "C" {
    pub fn find_type_or_exit(x: *const ::std::os::raw::c_char,
                             typelib: *mut TYPELIB,
                             option: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_type(x: *const ::std::os::raw::c_char,
                     typelib: *const TYPELIB, flags: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_type(to: *mut ::std::os::raw::c_char,
                     nr: ::std::os::raw::c_uint, typelib: *mut TYPELIB);
}
extern "C" {
    pub fn get_type(typelib: *mut TYPELIB, nr: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn copy_typelib(root: *mut MEM_ROOT, from: *mut TYPELIB)
     -> *mut TYPELIB;
}
extern "C" {
    #[link_name = "sql_protocol_typelib"]
    pub static mut sql_protocol_typelib: TYPELIB;
}
extern "C" {
    pub fn find_set_from_flags(lib: *const TYPELIB,
                               default_name: ::std::os::raw::c_uint,
                               cur_set: my_ulonglong,
                               default_set: my_ulonglong,
                               str: *const ::std::os::raw::c_char,
                               length: ::std::os::raw::c_uint,
                               err_pos: *mut *mut ::std::os::raw::c_char,
                               err_len: *mut ::std::os::raw::c_uint)
     -> my_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_rows {
    pub next: *mut st_mysql_rows,
    pub data: MYSQL_ROW,
    pub length: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_st_mysql_rows() {
    assert_eq!(::std::mem::size_of::<st_mysql_rows>() , 24usize);
    assert_eq!(::std::mem::align_of::<st_mysql_rows>() , 8usize);
}
impl Clone for st_mysql_rows {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_ROWS = st_mysql_rows;
pub type MYSQL_ROW_OFFSET = *mut MYSQL_ROWS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct embedded_query_result([u8; 0]);
pub type EMBEDDED_QUERY_RESULT = embedded_query_result;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_data {
    pub data: *mut MYSQL_ROWS,
    pub embedded_info: *mut embedded_query_result,
    pub alloc: MEM_ROOT,
    pub rows: my_ulonglong,
    pub fields: ::std::os::raw::c_uint,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_data() {
    assert_eq!(::std::mem::size_of::<st_mysql_data>() , 128usize);
    assert_eq!(::std::mem::align_of::<st_mysql_data>() , 8usize);
}
impl Clone for st_mysql_data {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_DATA = st_mysql_data;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_option {
    MYSQL_OPT_CONNECT_TIMEOUT = 0,
    MYSQL_OPT_COMPRESS = 1,
    MYSQL_OPT_NAMED_PIPE = 2,
    MYSQL_INIT_COMMAND = 3,
    MYSQL_READ_DEFAULT_FILE = 4,
    MYSQL_READ_DEFAULT_GROUP = 5,
    MYSQL_SET_CHARSET_DIR = 6,
    MYSQL_SET_CHARSET_NAME = 7,
    MYSQL_OPT_LOCAL_INFILE = 8,
    MYSQL_OPT_PROTOCOL = 9,
    MYSQL_SHARED_MEMORY_BASE_NAME = 10,
    MYSQL_OPT_READ_TIMEOUT = 11,
    MYSQL_OPT_WRITE_TIMEOUT = 12,
    MYSQL_OPT_USE_RESULT = 13,
    MYSQL_OPT_USE_REMOTE_CONNECTION = 14,
    MYSQL_OPT_USE_EMBEDDED_CONNECTION = 15,
    MYSQL_OPT_GUESS_CONNECTION = 16,
    MYSQL_SET_CLIENT_IP = 17,
    MYSQL_SECURE_AUTH = 18,
    MYSQL_REPORT_DATA_TRUNCATION = 19,
    MYSQL_OPT_RECONNECT = 20,
    MYSQL_OPT_SSL_VERIFY_SERVER_CERT = 21,
    MYSQL_PLUGIN_DIR = 22,
    MYSQL_DEFAULT_AUTH = 23,
    MYSQL_OPT_BIND = 24,
    MYSQL_OPT_SSL_KEY = 25,
    MYSQL_OPT_SSL_CERT = 26,
    MYSQL_OPT_SSL_CA = 27,
    MYSQL_OPT_SSL_CAPATH = 28,
    MYSQL_OPT_SSL_CIPHER = 29,
    MYSQL_OPT_SSL_CRL = 30,
    MYSQL_OPT_SSL_CRLPATH = 31,
    MYSQL_OPT_CONNECT_ATTR_RESET = 32,
    MYSQL_OPT_CONNECT_ATTR_ADD = 33,
    MYSQL_OPT_CONNECT_ATTR_DELETE = 34,
    MYSQL_SERVER_PUBLIC_KEY = 35,
    MYSQL_ENABLE_CLEARTEXT_PLUGIN = 36,
    MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS = 37,
    MYSQL_OPT_SSL_ENFORCE = 38,
    MYSQL_OPT_MAX_ALLOWED_PACKET = 39,
    MYSQL_OPT_NET_BUFFER_LENGTH = 40,
    MYSQL_OPT_TLS_VERSION = 41,
    MYSQL_OPT_SSL_MODE = 42,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_extention([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options {
    pub connect_timeout: ::std::os::raw::c_uint,
    pub read_timeout: ::std::os::raw::c_uint,
    pub write_timeout: ::std::os::raw::c_uint,
    pub port: ::std::os::raw::c_uint,
    pub protocol: ::std::os::raw::c_uint,
    pub client_flag: ::std::os::raw::c_ulong,
    pub host: *mut ::std::os::raw::c_char,
    pub user: *mut ::std::os::raw::c_char,
    pub password: *mut ::std::os::raw::c_char,
    pub unix_socket: *mut ::std::os::raw::c_char,
    pub db: *mut ::std::os::raw::c_char,
    pub init_commands: *mut st_mysql_options_st_dynamic_array,
    pub my_cnf_file: *mut ::std::os::raw::c_char,
    pub my_cnf_group: *mut ::std::os::raw::c_char,
    pub charset_dir: *mut ::std::os::raw::c_char,
    pub charset_name: *mut ::std::os::raw::c_char,
    pub ssl_key: *mut ::std::os::raw::c_char,
    pub ssl_cert: *mut ::std::os::raw::c_char,
    pub ssl_ca: *mut ::std::os::raw::c_char,
    pub ssl_capath: *mut ::std::os::raw::c_char,
    pub ssl_cipher: *mut ::std::os::raw::c_char,
    pub shared_memory_base_name: *mut ::std::os::raw::c_char,
    pub max_allowed_packet: ::std::os::raw::c_ulong,
    pub use_ssl: my_bool,
    pub compress: my_bool,
    pub named_pipe: my_bool,
    pub unused1: my_bool,
    pub unused2: my_bool,
    pub unused3: my_bool,
    pub unused4: my_bool,
    pub methods_to_use: mysql_option,
    pub ci: st_mysql_options__bindgen_ty_1,
    pub unused5: my_bool,
    pub report_data_truncation: my_bool,
    pub local_infile_init: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *const ::std::os::raw::c_char,
                                                                      arg3:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut ::std::os::raw::c_char,
                                                                      arg3:
                                                                          ::std::os::raw::c_uint)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub local_infile_end: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub local_infile_error: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void,
                                                                       arg2:
                                                                           *mut ::std::os::raw::c_char,
                                                                       arg3:
                                                                           ::std::os::raw::c_uint)
                                                      ->
                                                          ::std::os::raw::c_int>,
    pub local_infile_userdata: *mut ::std::os::raw::c_void,
    pub extension: *mut st_mysql_options_extention,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_options_st_dynamic_array([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_options__bindgen_ty_1 {
    pub client_ip: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bind_address: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_st_mysql_options__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<st_mysql_options__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<st_mysql_options__bindgen_ty_1>() ,
               8usize);
}
impl Clone for st_mysql_options__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_st_mysql_options() {
    assert_eq!(::std::mem::size_of::<st_mysql_options>() , 248usize);
    assert_eq!(::std::mem::align_of::<st_mysql_options>() , 8usize);
}
impl Clone for st_mysql_options {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_status {
    MYSQL_STATUS_READY = 0,
    MYSQL_STATUS_GET_RESULT = 1,
    MYSQL_STATUS_USE_RESULT = 2,
    MYSQL_STATUS_STATEMENT_GET_RESULT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_protocol_type {
    MYSQL_PROTOCOL_DEFAULT = 0,
    MYSQL_PROTOCOL_TCP = 1,
    MYSQL_PROTOCOL_SOCKET = 2,
    MYSQL_PROTOCOL_PIPE = 3,
    MYSQL_PROTOCOL_MEMORY = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mysql_ssl_mode {
    SSL_MODE_DISABLED = 1,
    SSL_MODE_PREFERRED = 2,
    SSL_MODE_REQUIRED = 3,
    SSL_MODE_VERIFY_CA = 4,
    SSL_MODE_VERIFY_IDENTITY = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct character_set {
    pub number: ::std::os::raw::c_uint,
    pub state: ::std::os::raw::c_uint,
    pub csname: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub comment: *const ::std::os::raw::c_char,
    pub dir: *const ::std::os::raw::c_char,
    pub mbminlen: ::std::os::raw::c_uint,
    pub mbmaxlen: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_character_set() {
    assert_eq!(::std::mem::size_of::<character_set>() , 48usize);
    assert_eq!(::std::mem::align_of::<character_set>() , 8usize);
}
impl Clone for character_set {
    fn clone(&self) -> Self { *self }
}
pub type MY_CHARSET_INFO = character_set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_methods([u8; 0]);
#[repr(C)]
pub struct st_mysql_stmt {
    pub mem_root: MEM_ROOT,
    pub list: LIST,
    pub mysql: *mut MYSQL,
    pub params: *mut MYSQL_BIND,
    pub bind: *mut MYSQL_BIND,
    pub fields: *mut MYSQL_FIELD,
    pub result: MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub read_row_func: ::std::option::Option<unsafe extern "C" fn(stmt:
                                                                      *mut st_mysql_stmt,
                                                                  row:
                                                                      *mut *mut ::std::os::raw::c_uchar)
                                                 -> ::std::os::raw::c_int>,
    pub affected_rows: my_ulonglong,
    pub insert_id: my_ulonglong,
    pub stmt_id: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub prefetch_rows: ::std::os::raw::c_ulong,
    pub server_status: ::std::os::raw::c_uint,
    pub last_errno: ::std::os::raw::c_uint,
    pub param_count: ::std::os::raw::c_uint,
    pub field_count: ::std::os::raw::c_uint,
    pub state: enum_mysql_stmt_state,
    pub last_error: [::std::os::raw::c_char; 512usize],
    pub sqlstate: [::std::os::raw::c_char; 6usize],
    pub send_types_to_server: my_bool,
    pub bind_param_done: my_bool,
    pub bind_result_done: ::std::os::raw::c_uchar,
    pub unbuffered_fetch_cancelled: my_bool,
    pub update_max_length: my_bool,
    pub extension: *mut st_mysql_stmt_extension,
}
#[test]
fn bindgen_test_layout_st_mysql_stmt() {
    assert_eq!(::std::mem::size_of::<st_mysql_stmt>() , 880usize);
    assert_eq!(::std::mem::align_of::<st_mysql_stmt>() , 8usize);
}
pub type MYSQL = st_mysql;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_res {
    pub row_count: my_ulonglong,
    pub fields: *mut MYSQL_FIELD,
    pub data: *mut MYSQL_DATA,
    pub data_cursor: *mut MYSQL_ROWS,
    pub lengths: *mut ::std::os::raw::c_ulong,
    pub handle: *mut MYSQL,
    pub methods: *const st_mysql_methods,
    pub row: MYSQL_ROW,
    pub current_row: MYSQL_ROW,
    pub field_alloc: MEM_ROOT,
    pub field_count: ::std::os::raw::c_uint,
    pub current_field: ::std::os::raw::c_uint,
    pub eof: my_bool,
    pub unbuffered_fetch_cancelled: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_res() {
    assert_eq!(::std::mem::size_of::<st_mysql_res>() , 184usize);
    assert_eq!(::std::mem::align_of::<st_mysql_res>() , 8usize);
}
impl Clone for st_mysql_res {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_RES = st_mysql_res;
extern "C" {
    pub fn mysql_server_init(argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char,
                             groups: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_server_end();
}
extern "C" {
    pub fn mysql_thread_init() -> my_bool;
}
extern "C" {
    pub fn mysql_thread_end();
}
extern "C" {
    pub fn mysql_num_rows(res: *mut MYSQL_RES) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_num_fields(res: *mut MYSQL_RES) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_eof(res: *mut MYSQL_RES) -> my_bool;
}
extern "C" {
    pub fn mysql_fetch_field_direct(res: *mut MYSQL_RES,
                                    fieldnr: ::std::os::raw::c_uint)
     -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_fetch_fields(res: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_row_tell(res: *mut MYSQL_RES) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_tell(res: *mut MYSQL_RES) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_field_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_affected_rows(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_insert_id(mysql: *mut MYSQL) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_errno(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_error(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_sqlstate(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_warning_count(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_info(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_thread_id(mysql: *mut MYSQL) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_character_set_name(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_set_character_set(mysql: *mut MYSQL,
                                   csname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_init(mysql: *mut MYSQL) -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_ssl_set(mysql: *mut MYSQL,
                         key: *const ::std::os::raw::c_char,
                         cert: *const ::std::os::raw::c_char,
                         ca: *const ::std::os::raw::c_char,
                         capath: *const ::std::os::raw::c_char,
                         cipher: *const ::std::os::raw::c_char) -> my_bool;
}
extern "C" {
    pub fn mysql_get_ssl_cipher(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_change_user(mysql: *mut MYSQL,
                             user: *const ::std::os::raw::c_char,
                             passwd: *const ::std::os::raw::c_char,
                             db: *const ::std::os::raw::c_char) -> my_bool;
}
extern "C" {
    pub fn mysql_real_connect(mysql: *mut MYSQL,
                              host: *const ::std::os::raw::c_char,
                              user: *const ::std::os::raw::c_char,
                              passwd: *const ::std::os::raw::c_char,
                              db: *const ::std::os::raw::c_char,
                              port: ::std::os::raw::c_uint,
                              unix_socket: *const ::std::os::raw::c_char,
                              clientflag: ::std::os::raw::c_ulong)
     -> *mut MYSQL;
}
extern "C" {
    pub fn mysql_select_db(mysql: *mut MYSQL,
                           db: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_query(mysql: *mut MYSQL, q: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_send_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_real_query(mysql: *mut MYSQL,
                            q: *const ::std::os::raw::c_char,
                            length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_store_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_use_result(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_get_character_set_info(mysql: *mut MYSQL,
                                        charset: *mut MY_CHARSET_INFO);
}
extern "C" {
    pub fn mysql_session_track_get_first(mysql: *mut MYSQL,
                                         type_: enum_session_state_type,
                                         data:
                                             *mut *const ::std::os::raw::c_char,
                                         length: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_session_track_get_next(mysql: *mut MYSQL,
                                        type_: enum_session_state_type,
                                        data:
                                            *mut *const ::std::os::raw::c_char,
                                        length: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_local_infile_handler(mysql: *mut MYSQL,
                                          local_infile_init:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *const ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_read:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          local_infile_end:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void)>,
                                          local_infile_error:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void,
                                                                                         arg2:
                                                                                             *mut ::std::os::raw::c_char,
                                                                                         arg3:
                                                                                             ::std::os::raw::c_uint)
                                                                        ->
                                                                            ::std::os::raw::c_int>,
                                          arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mysql_set_local_infile_default(mysql: *mut MYSQL);
}
extern "C" {
    pub fn mysql_shutdown(mysql: *mut MYSQL,
                          shutdown_level: mysql_enum_shutdown_level)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_dump_debug_info(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_refresh(mysql: *mut MYSQL,
                         refresh_options: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_kill(mysql: *mut MYSQL, pid: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_set_server_option(mysql: *mut MYSQL,
                                   option: enum_mysql_set_option)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_ping(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stat(mysql: *mut MYSQL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_client_version() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_host_info(mysql: *mut MYSQL)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_get_server_version(mysql: *mut MYSQL)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_get_proto_info(mysql: *mut MYSQL) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_list_dbs(mysql: *mut MYSQL,
                          wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_tables(mysql: *mut MYSQL,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_list_processes(mysql: *mut MYSQL) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_options(mysql: *mut MYSQL, option: mysql_option,
                         arg: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_options4(mysql: *mut MYSQL, option: mysql_option,
                          arg1: *const ::std::os::raw::c_void,
                          arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_get_option(mysql: *mut MYSQL, option: mysql_option,
                            arg: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_free_result(result: *mut MYSQL_RES);
}
extern "C" {
    pub fn mysql_data_seek(result: *mut MYSQL_RES, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_row_seek(result: *mut MYSQL_RES, offset: MYSQL_ROW_OFFSET)
     -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_field_seek(result: *mut MYSQL_RES,
                            offset: MYSQL_FIELD_OFFSET) -> MYSQL_FIELD_OFFSET;
}
extern "C" {
    pub fn mysql_fetch_row(result: *mut MYSQL_RES) -> MYSQL_ROW;
}
extern "C" {
    pub fn mysql_fetch_lengths(result: *mut MYSQL_RES)
     -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_fetch_field(result: *mut MYSQL_RES) -> *mut MYSQL_FIELD;
}
extern "C" {
    pub fn mysql_list_fields(mysql: *mut MYSQL,
                             table: *const ::std::os::raw::c_char,
                             wild: *const ::std::os::raw::c_char)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_escape_string(to: *mut ::std::os::raw::c_char,
                               from: *const ::std::os::raw::c_char,
                               from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_hex_string(to: *mut ::std::os::raw::c_char,
                            from: *const ::std::os::raw::c_char,
                            from_length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string(mysql: *mut MYSQL,
                                    to: *mut ::std::os::raw::c_char,
                                    from: *const ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_real_escape_string_quote(mysql: *mut MYSQL,
                                          to: *mut ::std::os::raw::c_char,
                                          from: *const ::std::os::raw::c_char,
                                          length: ::std::os::raw::c_ulong,
                                          quote: ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_debug(debug: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn myodbc_remove_escape(mysql: *mut MYSQL,
                                name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn mysql_thread_safe() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_embedded() -> my_bool;
}
extern "C" {
    pub fn mysql_read_query_result(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_reset_connection(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_mysql_stmt_state {
    MYSQL_STMT_INIT_DONE = 1,
    MYSQL_STMT_PREPARE_DONE = 2,
    MYSQL_STMT_EXECUTE_DONE = 3,
    MYSQL_STMT_FETCH_DONE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct st_mysql_bind {
    pub length: *mut ::std::os::raw::c_ulong,
    pub is_null: *mut my_bool,
    pub buffer: *mut ::std::os::raw::c_void,
    pub error: *mut my_bool,
    pub row_ptr: *mut ::std::os::raw::c_uchar,
    pub store_param_func: ::std::option::Option<unsafe extern "C" fn(net:
                                                                         *mut NET,
                                                                     param:
                                                                         *mut st_mysql_bind)>,
    pub fetch_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut st_mysql_bind,
                                                                 arg2:
                                                                     *mut MYSQL_FIELD,
                                                                 row:
                                                                     *mut *mut ::std::os::raw::c_uchar)>,
    pub skip_result: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut st_mysql_bind,
                                                                arg2:
                                                                    *mut MYSQL_FIELD,
                                                                row:
                                                                    *mut *mut ::std::os::raw::c_uchar)>,
    pub buffer_length: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
    pub length_value: ::std::os::raw::c_ulong,
    pub param_number: ::std::os::raw::c_uint,
    pub pack_length: ::std::os::raw::c_uint,
    pub buffer_type: enum_field_types,
    pub error_value: my_bool,
    pub is_unsigned: my_bool,
    pub long_data_used: my_bool,
    pub is_null_value: my_bool,
    pub extension: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_st_mysql_bind() {
    assert_eq!(::std::mem::size_of::<st_mysql_bind>() , 112usize);
    assert_eq!(::std::mem::align_of::<st_mysql_bind>() , 8usize);
}
impl Clone for st_mysql_bind {
    fn clone(&self) -> Self { *self }
}
pub type MYSQL_BIND = st_mysql_bind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_mysql_stmt_extension([u8; 0]);
pub type MYSQL_STMT = st_mysql_stmt;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum enum_stmt_attr_type {
    STMT_ATTR_UPDATE_MAX_LENGTH = 0,
    STMT_ATTR_CURSOR_TYPE = 1,
    STMT_ATTR_PREFETCH_ROWS = 2,
}
extern "C" {
    pub fn mysql_stmt_init(mysql: *mut MYSQL) -> *mut MYSQL_STMT;
}
extern "C" {
    pub fn mysql_stmt_prepare(stmt: *mut MYSQL_STMT,
                              query: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_execute(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_fetch_column(stmt: *mut MYSQL_STMT,
                                   bind_arg: *mut MYSQL_BIND,
                                   column: ::std::os::raw::c_uint,
                                   offset: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_store_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_param_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mysql_stmt_attr_set(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *const ::std::os::raw::c_void)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_attr_get(stmt: *mut MYSQL_STMT,
                               attr_type: enum_stmt_attr_type,
                               attr: *mut ::std::os::raw::c_void) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_param(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_bind_result(stmt: *mut MYSQL_STMT, bnd: *mut MYSQL_BIND)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_close(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_reset(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_free_result(stmt: *mut MYSQL_STMT) -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_send_long_data(stmt: *mut MYSQL_STMT,
                                     param_number: ::std::os::raw::c_uint,
                                     data: *const ::std::os::raw::c_char,
                                     length: ::std::os::raw::c_ulong)
     -> my_bool;
}
extern "C" {
    pub fn mysql_stmt_result_metadata(stmt: *mut MYSQL_STMT)
     -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_param_metadata(stmt: *mut MYSQL_STMT) -> *mut MYSQL_RES;
}
extern "C" {
    pub fn mysql_stmt_errno(stmt: *mut MYSQL_STMT) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_stmt_error(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_sqlstate(stmt: *mut MYSQL_STMT)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mysql_stmt_row_seek(stmt: *mut MYSQL_STMT,
                               offset: MYSQL_ROW_OFFSET) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_row_tell(stmt: *mut MYSQL_STMT) -> MYSQL_ROW_OFFSET;
}
extern "C" {
    pub fn mysql_stmt_data_seek(stmt: *mut MYSQL_STMT, offset: my_ulonglong);
}
extern "C" {
    pub fn mysql_stmt_num_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_affected_rows(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_insert_id(stmt: *mut MYSQL_STMT) -> my_ulonglong;
}
extern "C" {
    pub fn mysql_stmt_field_count(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mysql_commit(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_rollback(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_autocommit(mysql: *mut MYSQL, auto_mode: my_bool) -> my_bool;
}
extern "C" {
    pub fn mysql_more_results(mysql: *mut MYSQL) -> my_bool;
}
extern "C" {
    pub fn mysql_next_result(mysql: *mut MYSQL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_stmt_next_result(stmt: *mut MYSQL_STMT)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mysql_close(sock: *mut MYSQL);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
